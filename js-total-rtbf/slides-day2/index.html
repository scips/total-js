<!doctype html>
<html lang="fr">

  <head>
    <meta charset="utf-8">
    <title>JS Total • 2ème partie, 09/12/2015</title>

    <meta name="author" content="Christophe Porteneuve">

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <link rel="stylesheet" href="css/reveal.min.css">
    <link rel="stylesheet" href="css/theme/js-attitude.css" id="theme">

    <!-- For syntax highlighting -->
    <link rel="stylesheet" href="lib/css/tomorrow.css">

    <!-- If the query includes 'print-pdf', use the PDF print sheet -->
    <script>
      if (window.location.search.match( /print-pdf/gi))
        document.write( '<link rel="stylesheet" href="css/print/pdf.css" type="text/css" media="all">' );
      else
        document.write( '<link rel="stylesheet" href="css/print/paper.css" type="text/css" media="print">' );;
    </script>

    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->
  </head>

  <body class="no-anims">

    <div class="reveal">

      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
        <section id="intro">
          <h1>JS Total</h1>
          <h3 data-marker="intro-date">2ème partie, 09/12/2015</h3>
          <h4 data-marker="intro-trainers">Jean-Pierre Vincent @ JS Attitude</h4>
          <script>
            // Delicously hacky. Look away.
            if( navigator.userAgent.match( /(iPhone|iPad|iPod|Android)/i ) ) document.write( '<p style="color: rgba(0,0,0,0.3); text-shadow: none;">('+'Tap to navigate'+')</p>' );
          </script>
          <aside class="notes" data-markdown>
            slides sur http://delicious-insights.com/js-total/jst-day2/
          </aside>
        </section>

        <section id="overview">
          <h1>JS Total</h1>
          <h4 data-marker="overview-dates">4 journées du 8 au 11 décembre</h4>

          <ol>
            <li><span data-marker="day2">Aujourd’hui</span> : Outils, DevTools, modules et début SPA</li>
            <li><span data-marker="day3">Demain</span> : développement d’une SPA complète</li>
            <li><span data-marker="day4">Vendredi</span> : industrialisation et web mobile</li>
          </ol>
          <aside class="notes" data-markdown>
            slides sur http://delicious-insights.com/js-total/jst-day2/
          </aside>
        </section>

        <section id="edit-code">
          <section class="chapter">
            <h1>Pondre le code</h1>
            <h4>Mon éditeur chéri…</h4>
          </section>

          <section id="jshint">
            <h1>JSHint</h1>

            <p>Plus flexible/souple/tolérant</p>
            <p>A grandi au-delà de ce but originel pour faire de l'analyse statique de code (SCA) et fournir des recos de plus haut niveau aussi (complexité cyclomatique, etc.</p>
            <p><a href="http://www.jshint.com">jshint.com</a></p>

            <aside class="notes" data-markdown>
              Installation
              * package controler
              * SublimeLinter, puis SublimeLinter-jshint
              * ST 3 : npm install -g jshint

              Ce qu'on utilise en pratique.  Linting + infos de complexité.  Le projet `spa-basis` inclut un `.jshintrc` très détaillé et commenté, leur refiler expliquer qu'il est pris en compte par JSHint pour tout fichier au même niveau ou dessous ; ils peuvent donc se le coller dans leur `HOME` en virant peut-être juste certains trucs comme quelques `globals` et l'environnement Node, par exemple.

              * récupérer et éditer jshint-example.js
              * récupérer .jshintrc, le dérouler

              Leur faire installer SublimeLinter (surtout pas le JSLint / JSHint de base) dans ST et leur montrer quelques impacts (attention, il faut que le fichier soit sauvé).  Bien insister sur le côté débogage préemptif et donc gros gain de temps, notamment pour les fautes de frappe.
            </aside>
          </section>

          <section id="beautifiers">
            <h1>Beautifiers</h1>

            <p><a href="http://jsbeautifier.org/">JSBeautifier.org</a> et ses plugins (ex. pour <a href="https://github.com/jdc0589/JsFormat">Sublime Text 2</a>)</p>
            <p><a href="https://github.com/mishoo/UglifyJS2">UglifyJS</a> (Node) fait <i>aussi</i> du <i>beautifying</i>…</p>
            <p>Vous avez peut-être des fonctions inhérentes dans vos éditeurs ou EDI, etc.</p>
            <p>Pratique comme filtres automatiques dans un VCS…</p>

            <aside class="notes" data-markdown>
              Installation
              * JSFormat !
              * Jade, CoffeeScript, SASS et Stylus ?
              * JavaScript Next ? (changer les settings Sublimet Linter en rajoutant dans sublimelinter_syntax_map "JavaScriptNext":"javascript" )

              * Eclipse, WebStorm/PHPStorm et VS ont des réglages ultra-pointus,
              * sur ST le paquet JSFormat est à récupérer (surtout pour mater du JSON), et les DevTools en ont un aussi.
              * Si besoin d'un truc ultra-chiadé sur ST par exemple, voir [Uncrustify](http://uncrustify.sourceforge.net/) et son wrapper de config OSX [UncrustifyX](https://github.com/ryanmaxwell/UncrustifyX), qui envoient grave du paté !
            </aside>
          </section>
        </section>

        <section id="debug-consoles">
          <section class="chapter">
            <h1>Déboguer le desktop</h1>
            <h4>Console et panneaux avancés</h4>

            <p>(et aussi : <a href="http://discover-devtools.codeschool.com/">Discover DevTools</a> et <a href="http://www.youtube.com/playlist?list=PLNYkxOF6rcIBQ8j3J_PyM8JLAGKqZRByw">The Breakpoint</a>)</p>

            <aside class="notes" data-markdown>
              configuration de la console

              chrome://flag :

              * Activer les expérimentations dans les outils de développement
              * relancer chrome

              Cmd Alt J => ouvrir la console JS

              Cocher dans les outils de dev :

              * disable cache
              * enable JS source maps
              * enable CSS source maps
              * log XHR
              * show shadow DOM

              Montrer :
              * shortcuts
              * framework blackboxing
              * workspace
              * console.log d'un truc privé dans le code => save as global

            </aside>
          </section>

          <section id="console">
            <h1>La console</h1>

            <p>Bien plus que <code>console.log</code> !</p>
            <p>Complétion, Cmd+K/Ctrl+L, Shift+Return…</p>
            <p><a href="http://www.youtube.com/watch?v=4mf_yNLlgic&noredirect=1">Console Power User</a> !</p>
            <p>time / timeEnd</p>
            <p>dir, table</p>
            <p>$_, <em>Save As Global Variable</em>, copy</p>
            <p>$0 / inspect(el), Force Element State, $$</p>
            <p>monitorEvents, Break On… (+ Elements > Event Listeners)</p>

            <aside class="notes" data-markdown>
              .log : objets complexes, multi argument, .debug, .info, .warn, .error (stack trace)

* console.groupCollapsed('module 1')
* console.log('init');
* console.log('XHR');
* console.group('sous-module');
* console.log('autre');
* console.groupEnd();
* console.groupEnd();


* console.table( [
* ['name', 'age'],
* ['chris', 37],
* ['JP', 36]
* ]);

              * changement de contexte de frame
              * $- : faire un new Date(), puis $-
              * force element state : lien "console power user"
              * édition de CSS, colorpicker
              * monitorEvents( $0 ). $0 à $6
              * $$('p')
              * keys( document ) + copy( keys(document) )
            </aside>
          </section>

          <section id="panel-scripts">
            <h1>Le panneau Sources</h1>

            <p>Le pas à pas, en détail</p>
            <p>Des breakpoints sur <strong>tout</strong> !</p>
            <p>Expressions espions (watches)</p>
            <p>Pile d'appels (call stack).  Noms de fonctions.</p>
            <p>Portée</p>
            <p>Gestion des exceptions</p>
            <p><i>Beautifying</i> !</p>

            <aside class="notes" data-markdown>
              Démo sur la fonction de filtrage d'API de [l'API Prototype](http://api.prototypejs.org).

              * chercher une fonction filter (Ctrl+Shift+F)
              * breakpoint, pas à pas IN / OUT / OVER
              * breakpoint conditionnel (value.length > 4)
              * DOM breakpoint sur ul#search_results => on retrouve notre fonction filter
              * montrer closures (y compris quand elles ne sont pas là faute d'utilisation de la portée englobante)
              * dans panneau Elements => Events Listener, montrer tous les events de la page. + sélectionner un objet dans le DOM et décocher ancestors

              Sur Twitter :

              * démo break on XHR (sur action reply par ex.)
              * beautifying - pretty print
              * break on DOM events

              scp closure-debugger-hoisting-exception.html di:public/debug.html

              Sur [closure-debugger-hoisting-exception.html](http://delicious-insights.com/js-total/debug.html) :

              * mot clé debugger;
              * break on error
            </aside>
          </section>

          <section id="panel-resources">
            <h1>Le panneau Resources</h1>

            <p>Tout ce qui est stocké en local :</p>

            <ul>
              <li>Naviguer dans les sources ; iframes ; workers !</li>
              <li>Ressources chargées (catégorisées)</li>
              <li>Cookies</li>
              <li>Stockage session et local</li>
              <li>Bases de données</li>
              <li>AppCache</li>
            </ul>

            <aside class="notes" data-markdown>
              C'est le meilleur moyen de triturer ses cookies.  Indiquer qu'on utilisera les stockages local et session, ainsi qu'AppCache, le lendemain.

              appui long sur reload pour vider le cache (window only ?)
            </aside>
          </section>

          <section id="panel-network">
            <h1>Le panneau Network</h1>

            <p>Analyse des performances de chargement</p>
            <p>Distinction latence / chargement</p>
            <p>Visualisation détaillée (en-têtes, corps, preview…)</p>
            <p>Mode persistent (record)</p>
            <p>Toute l'activité : ressources, XHR, WebSockets…</p>

            <aside class="notes" data-markdown>
              PPC + network XHR + JSON + console.table

              Bien montrer les recoins des requêtes, le détail du timing, les previews, la copie cURL, parler des trucs HAR, et le Replay XHR (qui ne reprend pas les handlers, ceci dit ; juste pratique pour vérifier qu'on a débogué la couche serveur quand elle chiait à tort).

              clear cache, clear cookie, replay XHR

              démo HAR : save as HAR with content => harviewer (software is hard)
            </aside>
          </section>

          <section id="panel-timeline">
            <h1>Le panneau Timeline</h1>

            <p>Analyse des performances d'exécution</p>
            <p>Chargement / Parsing / Rendering / Painting</p>
            <p>Groupes asynchrones</p>
            <p>Monitoring événements, FPS, RAM ; GC !</p>
            <p>Mode persistent, là aussi.</p>
            <p>Réduction du bruit (&lt; 15ms)</p>

            <aside class="notes" data-markdown>
              Très dur à bien mettre en situation, comme Profiles.  Insister à mort sur [Discover DevTools](http://discover-devtools.codeschool.com/) pour bien les prendre en main.

              timeline event / frame / memory avec reveal.js


            </aside>
          </section>

          <section id="panel-profiles">
            <h1>Le panneau Profiles et Rendering</h1>

            <p>Préalable <strong>obligatoire</strong> à l'optimisation !</p>
            <p>Pas seulement JS : sélecteurs CSS et occupation RAM</p>
            <p>Profils/snapshots nommés + persistence possible</p>

            <aside class="notes" data-markdown>
              Très dur à bien mettre en situation, comme Timeline.  Insister à mort sur [Discover DevTools](http://discover-devtools.codeschool.com/) pour bien les prendre en main.

              rendering : Esc, avec FPS meter et paint rectangles
            </aside>
          </section>

          <section id="panel-audits">
            <h1>Le panneau Audits</h1>

            <p>Genre DOM Monster + GTMetrix…</p>
            <p>Performances <em>loadtime</em> + <em>runtime</em></p>
            <p>État actuel ou dès chargement</p>
            <p>Voir aussi <a href="http://javascriptrocks.com/performance/">JS Performance Rocks!</a></p>

            <aside class="notes" data-markdown>
              Montrer vite fait mais préférer PageSpeed Insights (français, plus exhaustif, file les ressources déjà optimisées). JP, tu as peut-être des conseils d'exploit/démo/liaisons ici, sans déborder en temps ?
            </aside>

          </section>

          <section id="panel-emulation">
            <h1>Le tiroir Émulation</h1>

            <p>Émuler le touch, la géoloc, l'accéléromètre</p>
            <p>CSS print</p>
            <p>RWD, taille d'écran et densité de pixels</p>
            <p>Network Throttling (y compris offline)</p>
            <p>User Agent</p>

            <aside class="notes" data-markdown>
              raccourci Esc de n'importe où
            </aside>

          </section>

        </section>

        <section id="debug-remote">
          <section class="chapter">
            <h1>Déboguer à distance</h1>
            <h4>sur les mobiles</h4>
          </section>

          <section id="weinre">
            <h1>Weinre</h1>
            <h4>WEb INspector REmote</h4>

            <p>Le WebInspector de WebKit (Chrome/Saf), connecté à un navigateur mobile via un serveur</p>
            <p>Fait partie de Apache Cordova (ex Phonegap)</p>
            <p><a href="http://people.apache.org/~pmuellr/weinre/docs/latest/">Les docs chez Apache</a></p>

            <aside class="notes" data-markdown>
              En parler parce que c'est la base, mais préciser qu'on utilisera toujours ça intégré à un autre système.

              * installation facile via NodeJS
              * Lance un serveur
              * Injection de script dans la page cible
              * affiche la vieille interface des debug tools webkit
              * du coup ça marche sur Android 2.3, vieux iOS, windows phone, webViews, TVs …

            </aside>
          </section>

          <section id="adobe-edge-inspect">
            <h1>Adobe Edge Inspect</h1>
            <h4>(ex Adobe Shadow)</h4>

            <p>Solution complète incluant Weinre (date un peu)</p>
            <p>Logiciel desktop + extension Chrome + app mobile</p>
            <p>Nécessite un compte Adobe Creative Cloud<br/>(gratuit pour 1 périphérique)</p>
            <p>Captures d'écran, etc.</p>
            <p><a href="http://html.adobe.com/edge/inspect/">Ça se passe ici</a></p>

            <aside class="notes" data-markdown>
              Faire une démo avec soit iPhone soit Android (soit les deux ? Ou une tablette et un téléphone…).  Penser à bien mettre tous les devices sur le réseau du laptop, et à utiliser l'IP du laptop (pas de DNS approprié en local).

              montrer navigator.userAgent, édition de CSS, screenshot, plein écran …

              Montrer aussi BrowserSync 2 http://www.browsersync.io/, la vidéo de démo montre un reload multi-browser, une injection de CSS, synchro de scroll, et l'utilisation de Weinre (1"10)
            </aside>
          </section>

          <section id="android-specific">
            <h1>Spécifiques Android</h1>

            <p>Chrome : <a href="https://developers.google.com/chrome/mobile/docs/debugging">debugging distant via la version desktop</a> en USB (nécessite toutefois le SDK Android + la config en mode développement du téléphone)</p>
            <aside class="notes" data-markdown>
              Android :

              * connecter l'USB
              * "à propos de l'appareil"
              * appuyer 7 fois sur le numéro de version
              * menu Options de développement
              * activer le debug USB
              * chrome://inspect/#devices
              * windows : + http://developer.android.com/tools/extras/oem-usb.html
              * sélection du device (avoir lancé chrome)
            </aside>
          </section>

          <section id="mobile-safari-specific">
            <h1>iOS / Mobile Safari</h1>

            <p>Sur iOS 5.x, on avait <a href="http://www.iwebinspector.com/">iWebInspector</a></p>
            <p>Depuis iOS 6 <a href="https://developer.apple.com/library/mac/documentation/AppleApplications/Conceptual/Safari_Developer_Guide/GettingStarted/GettingStarted.html#//apple_ref/doc/uid/TP40007874-CH2-SW2">on peut connecter via USB</a> Safari Desktop</p>
            <p>On espère pour bientôt : <a href="https://github.com/google/ios-webkit-debug-proxy">iOS WebKit Debug Proxy</a> (Lion+)</p>

            <aside class="notes" data-markdown>
              iWebInspector :

              * peut encore être utilisé pour les webview
              * MacOS 10.6 et 10.7 (donc pas 10.8 Mountain Lion)
              * breakpoints, profiling et le reste

              WebInspector Safari :
              * Avoir configuré sur iOS : Réglages > Safari > Avancé > Inspecteur Web. Lancer une page
              * Safari 7 > Développement > iPhone de ….

              iOS WebKit Debug Proxy :
              * Mac / linux, pas windows
              * encore un peu brut, ne marche pas à tous les coups
              * Lion+, Xcode 5



            </aside>
          </section>

          <section id="mobile-other-specific">
            <h1>Les autres</h1>

            <p>Opera Mobile : <a href="http://www.opera.com/dragonfly/documentation/remote/">Dragonfly</a></p>

            <p>Firefox (Fennec) : depuis la 15, <a href="https://hacks.mozilla.org/2012/08/remote-debugging-on-firefox-for-android/">debugging distant</a> simple à configurer, via TCP/IP (ou ADB forwarding).</p>

            <p>Windows Phone : <a href="http://blogs.msdn.com/b/visualstudioalm/archive/2014/04/04/diagnosing-mobile-website-issues-on-windows-phone-8-1-with-visual-studio.aspx">Visual Studio 2013</a>, et encore uniquement pour Windows Phone 8.1… Mais complet.  Et <strong>aussi via Weinre</strong></p>

            <p>iOS et Android pilotés par les Firefox Developer Tools (<a href="https://developer.mozilla.org/fr/docs/Outils/Firefox_Tools_Adapter">projet Valence</a>)</p>

            Sinon <strong>Weinre</strong> pour tout le monde!
            <aside class="notes" data-markdown>
            </aside>
          </section>

        </section>

        <section id="preprocessors">
          <section class="chapter">
            <h1>Préprocesseurs</h1>
            <h4>Parce que des fois on en veut plus</h4>

            <aside class="notes" data-markdown>

            L'idée d'un pré-proc remonte avant CSS1

              * notions de variables (constantes), fonctions (mixin), conditions …

              Évoquer Less et Sass (de toute façon dans la démo SourceMaps).

              * Less lent, syntaxe discutable (@ ou . pour un mixin ), pas de gestion d'erreur
              * Less = bootstrap (un pote) => connu
              * Sass : + de possibilités que Less, code généré efficace. Depuis Sass 3, interprète correctement le .css
              * Compass : librairie de mixin pour Sass, mais bugs et parfois très lourd (grille = 1.2Mo). Préférer micro-lib ou bourbon.io (montrer juste la démo en haut de page)
            </aside>
          </section>

          <section id="stylus">
            <h1>Stylus</h1>

            <p>J'aime &hearts; :-)</p>
            <p>Par les types qui font Socket.IO et plein de trucs Node</p>
            <p>Syntaxe flexible, adaptable à vos goûts</p>
            <p>Transparence des mixins/prefixers</p>
            <p>Petites syntaxes <strong>qui tuent</strong></p>
            <p><a href="http://learnboost.github.com/stylus/">learnboost.github.com/stylus</a></p>

            <aside class="notes" data-markdown>
              Stylus :

              * Par <a href="https://github.com/visionmedia">le malade</a> qui fait aussi express, jade (template HTML), mocha, commander…
              * syntaxe à la coffee mais configurable
              * renvoie des erreurs, réf au parent, images inline
              * librairie de mixins Nib : http://visionmedia.github.io/nib/ (voir les mixins vendor-prefix, clearfix, ellipsis et dégradés )
              * commentaires avec // :)
            </aside>
          </section>

          <section id="stylus-demo">
            <h1>Stylus : exemple</h1>

            <pre><code class="stylus">overflow()
  if arguments[0] == ellipsis
    ellipsis()
  else
    overflow: arguments

size()
  if length(arguments) == 1
    width: arguments[0]
    height: arguments[0]
  else
    width: arguments[0]
    height: arguments[1]

box-shadow()
  vendor('box-shadow', arguments, only: webkit official)</code></pre>
            <aside class="notes" data-markdown>
              * fonction overflow, qui permet de faire overflow: scroll; ou de générer le code pour ellipsis (de nib)
              * fonction size permet d'avoir une height === width
              * fonction box-shadow, permet d'ajouter les préfixes
            </aside>
          </section>

          <section id="coffeescript">
            <h1>CoffeeScript</h1>

            <p>Juste une tuerie™</p>
            <p>Transpiler JavaScript (y'en a plein)</p>
            <p>Pas <strong>du tout</strong> que pour les n00bs : chouchou des gourous aussi…  Inspire énormément ES.next.</p>
            <p>Évite les pièges, promeut les bonnes pratiques, améliore les perfs, sauve des chatons.</p>
            <p>De plus en plus de libs et frameworks majeurs l'utilisent comme langage de dev.</p>
            <p><a href="http://coffeescript.org/">coffeescript.org</a></p>

            <aside class="notes" data-markdown>
              * 4 ans, inspire ES.Next
              * également backbone, underscore, doco

              * arguments par défaut
              * classes : constructeur, méthodes
              * héritage avec extends
              * binding du contexte (@ = this), fat arrow (comme ES6)
              * égalité stricte
              * array slice
              * jamais de variable globale
              * plus de variable hiding
              * chained comparison
              * commentaire dans les RegExp
              * tout est expression=> les for peuvent renvoyer des valeurs
            </aside>
          </section>

          <section id="coffeescript-demo">
            <h1>Coffee : exemple</h1>

            <pre><code>awardMedals = (first, second, others...) ->
  gold   = first
  silver = second
  rest   = others

math =
  root:   Math.sqrt
  square: square
  cube:   (x) -> x * square x

foods = ['broccoli', 'spinach', 'chocolate']
eat food for food in foods when food isnt 'chocolate'

yearsOld = max: 10, ida: 9, tim: 11

ages = for child, age of yearsOld
  "#{child} is #{age}"

letTheWildRumpusBegin() unless answer is no</code></pre>

            <aside class="notes" data-markdown>
              * splats (range les arguments en trop dans un tableau à part)
              * objet literal
              * unless (inverse du if)
              * templating
              * http://js2.coffee/ pour transpiler dans les 2 sens


              Si on a le temps (on doit boucler la démo avant de partir déjeuner), on peut ici jouer un peu avec la console interactive du site de CoffeeScript.
            </aside>
          </section>

          <section id="sourcemap-demo">
            <h1>Source Maps</h1>
            <h2>Comment deboguer du code généré ?</h2>
            <p>Les pré-proc c'est joli, mais le navigateur ne lit que JS et CSS</p>
            <p>Idée de base : faire le lien entre le code généré et le code original.</p>
            <p>Marche aussi pour le code minifié, les concaténations…</p>
            <p>Comme à la maison : inspection des styles, point d'arrêt …</p>

            <aside class="notes" data-markdown>
              Expliquer en allant sur un site avec sourcemaps :
              * par exemple  http://dev.fontdragr.com/
              * montrer la source : un seul fichier JS
              * montrer le réseau : un seul fichier S
              * montrer le panneau sources : tous les fichiers apparaissent un par un, déminifiés

              OU montrer spa-basis en local :
              * dans spa-basis : npm start
              * localhost:3333
              * montrer la source : un seul fichier JS et un CSS
              * montrer le réseau : un seul JS et un seul CSS
              * dans sources, montrer qu'on a l'intégralité des fichiers JS


              OU dans demos-day2:

              * montrer les sources (index + coffee + scss)
              * expliquer le watcher, le lancer, montrer que les fichiers ont été générés
              * afficher via localhost ()
              * montrer le réseau (.css et .js, puis sourcemap, puis .scss et .coffee)
              * inspecter le style du H1, de l'input
              * point d'arrêt JS
            </aside>
          </section>
        </section>

        <section id="what-can-we-use">
          <section class="chapter">
            <h1>À quoi a-t-on droit ?</h1>
            <h4>Et comment compenser ?</h4>
          </section>

          <section id="refs">
            <h1>Références</h1>

            <p>
              <a href="http://caniuse.com/">CanIUse</a>
              <span class="fragment">+ <a href="http://caniuse.com/#stats_import">Google Analytics</a> = <strong>Awesome</strong> !</span>
            </p>
            <p class="fragment"><a href="http://html5please.com/">HTML5 Please</a> : détails de prise en charge et polyfills</p>
            <p class="fragment"><a href="http://html5test.com/">HTML5Test</a>&nbsp;: et ton navigateur, il roxxe&nbsp;?</p>

            <aside class="notes" data-markdown>
              Faire une démo avec un de vos sites sur GA.  Penser à purger votre LocalStorage CIU avant, pour ne pas être d'entrée de jeu en mode Custom.  Attention, la beta en cours peut déconner sur le custom…
            </aside>
          </section>

          <section id="modernizr">
            <h1>Modernizr</h1>

            <p>In-page feature detection</p>
            <p>Sans doute le seul script forcément à chargement synchrone, et dans le head :-)</p>
            <p>À peu près tous les aspects de CSS2/3 et « HTML5 »</p>
            <p>Classes positives/négatives sur le document : évite au passage de saloper nos feuilles à coups de hacks CSS</p>
            <p><a href="http://modernizr.com/">modernizr.com</a></p>

            <aside class="notes" data-markdown>
              « Le seul script qui devrait être chargé en synchrone depuis le `&lt;head&gt;` »

              * démo du packaging custom
              * on peut montrer que ça s'exécute super rapidement (console.time())
            </aside>
          </section>

          <section id="polyfills">
            <h1>Polyfills</h1>

            <p>Un polyfill est un ersatz, un substitut qui tente de fournir une API identique (ou au moins équivalente) à celle d'une fonction non prise en charge par l'environnement (typiquement le navigateur)</p>
            <p>Y'en a <a href="https://github.com/Modernizr/Modernizr/wiki/HTML5-Cross-Browser-Polyfills">plein</a>&nbsp;!</p>
            <p>Les fameux <a href="http://code.google.com/p/ie7-js/">IEx.js</a> de Dean Edwards, <a href="http://raphaeljs.com/">Raphaël</a>, <a href="https://github.com/afarkas/html5shiv">html5shiv</a>, <a href="http://code.google.com/p/explorercanvas/">ExCanvas</a>, <a href="http://sublimevideo.net/">SublimeVideo</a>, <a href="http://socket.io/">Socket.IO</a>, <a href="https://github.com/kriskowal/es5-shim/">es5-shim</a>…</p>
            <aside class="notes" data-markdown>
              Faire le distingo entre *shim* (API identique au natif, même si partielle, ex. ES5-Shim ou ExCanvas) et *polyfill* (API spécifique car l'identique est infaisable, ex. SVG).
            </aside>
          </section>
        </section>

        <section id="codebase">
          <section class="chapter">
            <h1>Organiser la codebase</h1>
          </section>

          <section id="modules">
            <h1>Modules</h1>

            <p><a href="http://requirejs.org/docs/why.html">Pourquoi des modules ?</a></p>
            <p><a href="http://www.commonjs.org/specs/modules/1.0/">CommonJS</a></p>
            <p><a href="https://github.com/amdjs/amdjs-api/wiki/AMD">AMD</a></p>
            <p><a href="http://wiki.ecmascript.org/doku.php?id=harmony:modules">Harmony</a></p>

            <aside class="notes" data-markdown>
              Introduire la notion avant de parler des formats :

              * grosse codebase, diviser pour mieux régner
              * réutilisation de code
              * gestion des dépendances complexes
              * pas de pollution globale
            </aside>
          </section>

          <section id="commonjs">
            <h1>CommonJS</h1>

            <p>Le format historique, synchrone, popularisé par Node</p>
            <p>On parle en fait de CommonJS/1.0 (plein d'extensions…)</p>
            <p>Très facile à comprendre :</p>

            <br/>
            <p class="fragment"><code>exports.<i>key</i> = <i>value</i></code></p>
            <p class="fragment"><code><i>mod</i> = require('<i>pathspec</i>')</code></p>

            <aside class="notes" data-markdown>
              * la base de Node.js, Brunch et Browserify (chargeur de fichier concaténés)
              * on en fera dans la SPA de demain
              * Un fichier = un module
              * construit l'arbre des dépendances
              * Enrobage automatique donc obligatoire
              * toute variable doit être locale
              * renvoi de l'API publique avec exports.key ou module.exports
              * de l'autre côté : var machin = require('chemin') sans le .js
            </aside>
          </section>

          <section id="commonjs-2">
            <h1>CommonJS</h1>
            <p><img src="assets/commonjs.png"></p>
          </section>

          <section id="amd">
            <h1>AMD</h1>

            <p>Mais <a href="http://requirejs.org/docs/whyamd.html">pourquoi&nbsp;?</a></p>
            <p>Asynchronous Module Definition</p>
            <p>Conçu notamment pour les browsers</p>
            <p>Tout module CommonJS peut être « enrobé » en AMD</p>
            <p>Principal loader : <a href="http://requirejs.org/">RequireJS</a></p>
            <p>Clé de voute :</p>
            <br/>
            <p><code>define('<i>name</i>', [<i>path, …</i>], <i>cb</i>(<i>mod, …</i>) {})</code></p>

            <aside class="notes" data-markdown>
              * machin = require(truc) pas possible à cause de l'async, d'où callback
              * Enrobage manuel donc pas obligatoire…
              * grosse mode il y a qlqs années. est resté requireJS (et LabJS, yepnope.js …)

            </aside>
          </section>

          <section id="amd-2">
            <h1>AMD</h1>
            <p><img src="assets/amd.png"></p>
            <aside class="notes" data-markdown>
             * explicite avec define + return de l'API publique
             * nom du module peut être différent du nom du fichier (mais à configurer)
             * dépendances listées + référence locale
             * tri topologique et décision de téléchargement
            </aside>

          </section>

          <section id="harmony-modules">
            <h1>Modules Harmony</h1>

            <p><a href="http://jsmodules.io/">ES6 fournit une syntaxe native de modules</a>.</p>
            <p>Syntaxe souple, inspirée entre autres de Python.  Déjà disponible dans certaines implémentations préalables (Node 0.11, Chrome 35+, Firefox 25+…).</p>

            <p><a href="http://jsmodules.io/cjs.html">Comparez avec CommonJS</a> (mapping facile)</p>
            <p><a href="https://github.com/systemjs/systemjs">SystemJS</a> est un chargeur universel qui permet, dès maintenant, de faire collaborer les 3 types de modules et les scripts globaux, en cas de besoin.  Pour ES6, il repose sur l'excellent shim <a href="https://github.com/ModuleLoader/es6-module-loader">es6-module-loader</a>.</p>

            <aside class="notes" data-markdown>
              * prévu pour 2013, puis début 2014, mi-2014
              * marche dans Fx et options avancées de Chrome
              * même concepts que CommonJS mais pas compatible.
              * mais traducteurs et transpiler existent
              * concepts : modules synchrone, pré-compilation, résolution de l'arbre au parsing ou à l'exécution

              * 3 nouveaux mot clés : module, export, import
              * montrer la syntaxe sur le site
              * exemple jQuery : import $ from jquery
            </aside>
          </section>
        </section>

        <section id="frameworks">
          <section class="chapter">
            <h1>Frameworks</h1>
          </section>

          <section id="why-frameworks">
            <h1>Dis papa pourquoi ?</h1>

            <p><strong>Parce que !</strong></p>
            <p>Dès qu'on commence à avoir une masse de code, un formalisme et un socle bien testé et bien maintenu deviennent indispensables.  C'est comme pour le côté serveur !</p>

            <p>On perçoit quelques grandes catégories :</p>

            <p>La base : le squelette de MVC, sans plus</p>
            <p>Les <i>full clients</i> : la totale… pour le côté client</p>

            <aside class="notes" data-markdown>
              * Pour arretter de réinventer la roue
              * base MVC : pas de structure ou de syntaxe imposée
              * full clients : prends des décisions sur la vue, le templating, le routage, la communication serveur
              * full stack : généralement Node, comme Meteor. Dur à aborder
            </aside>
          </section>

          <section id="frameworks-basic">
            <h1>La base</h1>
            <h2><a href="http://backbonejs.org/">Backbone</a></h2>

            <p>Comme son nom l’indique, juste l’ossature critique</p>
            <p><strong>De loin le plus répandu</strong> (même sans marketing)</p>
            <p>Une couche modèle bien solide, à la base REST+JSON</p>
            <p>Couche routeur pas mal</p>
            <p>Couche vue minimaliste mais <strong>riche en BP</strong></p>
            <p>Énormément de <a href="http://backplug.io/">plugins</a> pour enrichir le tout</p>
            <p>(notamment <a href="http://marionettejs.com/">Marionette</a> pour ajouter du lourd côté vues)</p>

            <aside class="notes" data-markdown>
              * le plus connu (300 fois plus de sites que angular ou ember)
              * pérenne, open source, solide, syntaxe compréhensible
              * Model : solide, facilite communication serveur
              * routage : OK, gère pushState de HTML5
              * événements, facilite les bonnes pratiques jQuery
              * View (qui est plus un Controler en fait), on y rajoute parfois du Marionette ou du thorax (Handlebars)
            </aside>

          </section>

          <section id="frameworks-full-client">
            <h1>Full Client</h1>

            <p><a href="http://emberjs.com/">Ember.js</a></p>
            <p><a href="http://angularjs.org/">Angular.js</a></p>
            <p>Backbone + <a href="http://marionettejs.com/">Marionette</a></p>
            <p><a href="https://github.com/chaplinjs/chaplin">Chaplin</a></p>
            <p><a href="http://walmartlabs.github.com/thorax/">Thorax</a></p>
            <p>…</p>
          </section>

          <section id="frameworks-angular">
            <h1>Full Client</h1>
            <h2><a href="http://angularjs.org/">Angular.js</a></h2>

            <p>Déjà ancien mais Google bombarde en marketing depuis 2010</p>
            <p>Sur-architecturé ; ratio puissance/complexité plutôt bas</p>
            <p>Soucis récurrents sur les choix de data sources, les scopes…</p>
            <p>Les directives et le dirty checking sont très lourds en perfs</p>
            <p>Angular 2, sera nettement mieux mais 10% compatible 1.</p>
            <p><strong>Beaucoup de bons concepts mais l'exécution est faiblarde.</strong></p>

            <aside class="notes" data-markdown>
              Angular :

              * pas du vrai open source : pull request ignorées
              * Google aime t il JS ? => dart, GWT
              * retour de stagiaires formation Node : marre d'angular, on passe à Ember
              * 4 types de datasource !
              * scope compliqué à comprendre
              * directives = webcomponents, top pour la testabilité
              * bon écosystème (builder, runner)
              * sur-architecturé => http://codeofrob.com/entries/you-have-ruined-javascript.html
              * tu te sens d'attendre IE 13 ?
              * tient pas le nombre d'infos à afficher à l'écran
              * on aime ou pas les directives dans le DOM
              * Polémique Angular 2 : ré-écriture complète
            </aside>
          </section>

          <section id="frameworks-ember">
            <h1>Full Client</h1>
            <h2><a href="http://emberjs.com/">Ember.js</a></h2>

            <p>Issu de SproutCore ; influencé par Rails</p>
            <p>Yehuda Katz &amp; Tilde (jQuery, Rails, Handlebars…)</p>
            <p>Bon ratio puissance/complexité</p>
            <p>Porte de sortie fréquente des « brûlés par Angular »</p>
            <p>Désormais 100% ES6 (transpilé), dont modules</p>
            <p>Data binding plus léger et performant, via HTMLBars</p>

            <aside class="notes" data-markdown>
              Ember :

              * récent, mais vient de sproutcore, pour l'appli iCloud
              * influence Rails
            </aside>
          </section>

          <section id="frameworks-over-backbone">
            <h1>Full Client</h1>
            <h2>Solutions basées Backbone</h2>

            <h3><a href="https://github.com/chaplinjs/chaplin">Chaplin</a></h3>
            <p>Équivalent à Backbone + Marionette + du sucre syntaxique et des conventions de structuration et de nommage ; très sympa.</p>

            <h3><a href="http://walmartlabs.github.com/thorax/">Thorax</a></h3>
            <p>Le plus « battle-tested » au monde : au cœur de Walmart Mobile.  Énormément de services, factories, conventions, etc.  Archi industrielle adaptée aux (très) grosses applis clients.</p>
          </section>
          <aside class="notes" data-markdown>
              * thorax : au niveau de angular si on veut de la grosse architecture
            </aside>
        </section>

        <section>
          <section id="brunch" class="chapter">
            <h1><a href="http://brunch.io/">Brunch.io</a></h1>

            <p>Tout le monde parle de Grunt, Gulp, Broccoli…  Mais Brunch est là depuis 2011 et les enterre tous en <strong>application assembly</strong>.</p>

            <p>Pas un exécuteur générique de tâches</p>
            <p>Une vraie pipeline optimisée pour le <a href="http://brunch.io/compare.html">build d'applis</a></p>
            <p>Extrêmement <strong>réactif</strong> : entre 60ms et 200ms de la sauvegarde de fichier à la fin des rebuilds appropriés.</p>
            <p>Énormément de puissance en très (très) peu de config ; repose plutôt sur plein de conventions (mais reste configurable)</p>
            <p>Écosystème très riche de <a href="http://brunch.io/plugins.html">plugins</a></p>

            <aside class="notes" data-markdown>
              grunt
              * travaille au niveau du fichier

              Gulp
              * marche en flux

              Bizarrement, nous on préfère Brunch.  En gros, défonce Yeoman et ses énormes scripts Grunt en perf.  Mais Yeoman fait plein de trucs en plus, Brunch est un **assembleur d'appli** ; en revanche, à ce jeu-là, il enterre tout le monde (Grunt, Gulp, etc.).

              Brunch
              * en concurrence avec les nouveaux : gulp, brocoli
              * depuis 2011
              * un vrai builder d'application
              * en mode pipeline

              plugins
              * templating
              * tous les transpilers
              * les minifiers, spriter, optimisation d'images
              * linters, documentation, autoreload
              * appcache, cache client en refaisant les URLs …


              Ça tombe bien, c'est là qu'on DL `spa-basis.zip`, qu'on la décompresse, `npm install` et `npm start`.  Du coup quand ça marche, on peut faire du Cmd+S et montrer le temps de réaction de Brunch :-)

              Pour les Windowsiens : activer l'option `usePolling` s'ils loupent des modifs / nouveaux fichiers (ça sera plus lent à réagir mais au moins ça réagira).

              parfois sur du linux :
              npm config rm proxy
              npm config rm http-proxy
              npm config rm https-proxy
            </aside>
          </section>

          <section id="brunch-config">
            <h1>Config basique</h1>

            <p>Fichier <code>brunch-config.coffee</code> (ou <code>.js</code>)</p>

            <pre><code class="coffeescript">exports.config =
  files:
    javascripts:
      joinTo: 'app.js'
    stylesheets:
      joinTo: 'app.css'
    templates:
      joinTo: 'app.js'</code></pre>

            <p>JS = sources ES3/5/6, TypeScript, CoffeeScript, etc.</p>
            <p>Styles = sources CSS, SASS, LESS, Stylus, etc.</p>
            <p>Templates = sources Handlebars, Jade, etc.</p>
          </section>

          <section id="brunch-output">
            <h1>Ce que ça fait</h1>

            <ol>
              <li>Transpiling (ES6, CoffeeScript, TypeScript…)</li>
              <li>Préprocesseurs (LESS, SASS, Stylus…)</li>
              <li>Précompilation de templates vers JS (Handlebars, Jade…)</li>
              <li>Enrobage en modules (par défaut CommonJS)</li>
              <li>Concaténation intelligente</li>
              <li>Source Maps v3</li>
              <li>Minification optimale (JS, CSS) si en prod</li>
            </ol>

            <p>Si le plugin est présent, ses traitements sont automatiques !</p>

            <p>Mais aussi : spriting et optimisation des images, maintenance manifeste AppCache, injection live CSS, reloading si changement JS, etc.</p>
          </section>

          <section id="brunch-conventions">
            <h1>Conventions Brunch</h1>

            <p>Tout ça est configurable finement, mais par défaut :</p>

            <ul>
              <li>Les dossiers exploités sont <code>app/</code> et <code>vendor/</code></li>
              <li>Le dossier cible est <code>public/</code></li>
              <li>Les fichiers dont le nom démarre par <code>_</code> sont ignorés (on suppose qu'ils seront importés/inclus par d'autres)</li>
              <li>Le contenu des dossiers <code>assets/</code> est copié verbatim</li>
              <li>Les scripts dans les dossiers <code>vendor/</code> ne sont pas enrobés en modules, simplement concaténés</li>
              <li>Les autres scripts sont enrobés en modules CommonJS avec un nom dérivé de leur chemin sous <code>app/</code></li>
            </ul>
          </section>

          <section id="brunch-plugins">
            <h1>Plugins Brunch</h1>

            <p>Ce sont des modules Node qu'il suffit d'installer en local pour qu'ils soient pris en compte.</p>
            <p>Ils s'inscrivent sur un type de fichier (<code>javascript</code>, <code>stylesheets</code> ou <code>templates</code>) et 1+ extension/motif de fichier.</p>
            <p>Par exemple, <code>jade-brunch</code> s'inscrit sur le type <code>templates</code> pour l'extension <code>.jade</code>.</p>
            <p>Par défaut, Brunch ne traite aucun type de fichier d'office ; il lui faudrait au moins <code>javascript-brunch</code> pour s'occuper des <code>.js</code> et <code>css-brunch</code> pour s'occuper des <code>.css</code>.  Donc très léger !</p>

            <p>Y'en a <a href="http://brunch.io/plugins.html">des tonnes</a> :-)</p>
          </section>

          <section id="brunch-watch">
            <h1>Watcher Brunch</h1>

            <p>La commande <code>brunch build</code> fait un build one-shot, mais…</p>
            <p><code>brunch watch</code> poursuit en surveillant les dossiers définis pour mettre à jour, <strong>super vite</strong>, les fichiers cibles nécessaires.</p>
            <p>Elle peut même fournir un mini-serveur HTTP sur le dossier cible, avec <code>brunch watch --server</code></p>
          </section>

          <section id="brunch-prod">
            <h1>Brunch pour la prod</h1>

            <p>Par défaut, les fichiers produits sont orientés développement : HTML indenté, JS et CSS non minifiés, etc.</p>
            <p>Pour une release, on demande à Brunch de produire les versions de production avec <code>brunch build --production</code></p>
            <p>Si les plugins idoines sont présents (ex. <code>uglify-js-brunch</code> et <code>clean-css-brunch</code>), une minification optimale est effectuée.  On peut aussi optimiser les images, etc.</p>
          </section>
        </section>

        <section>
          <section id="spa-intro" class="chapter">
            <h1>Notre p’tite SPA</h1>
          </section>

          <section id="what-does-it-do">
            <h1>Que fait-elle ?</h1>

            <p>Sorte de µ-Foursquare</p>
            <p>Regarde où on est, cherche des endroits où manger, check-in !</p>
            <p>Historise les check-ins</p>
            <p>Gestion pratique du offline</p>

            <aside class="notes" data-markdown>
              on peut faire une démo en local de spa-final
            </aside>
          </section>

          <section id="spa-brunch-config">
            <h1>Config Brunch (1/2)</h1>

            <pre><code class="coffeescript">files:
  javascripts:
    joinTo: 'app.js'
  stylesheets:
    joinTo: 'app.css'
  templates:
    joinTo: 'app.js'

modules:
  nameCleaner: (path) ->
    path
      # Strip app/ and app/externals/ prefixes
      .replace /^app\/(?:externals\/)?/, ''
      # Allow -x.y[.z…] version suffixes in mantisses
      .replace /-\d+(?:\.\d+)+/, ''
      # Allow -fr lang suffixes in mantisses
      .replace '-fr.', '.'
</code></pre>

            <aside class="notes" data-markdown>
              nameCleaner : exemple require('moment') ira chercher app/externals/moment-2.2.1-fr.js
            </aside>
          </section>

          <section id="spa-brunch-config-2">
            <h1>Config Brunch (2/2)</h1>

            <pre><code class="coffeescript">plugins:
  appcache:
    externalCacheEntries: [
      'http://maps.gstatic.com/mapfiles/place_api/icons/bar-71.png'
      'http://maps.gstatic.com/mapfiles/place_api/icons/generic_business-71.png'
      'http://maps.gstatic.com/mapfiles/place_api/icons/restaurant-71.png'
      'http://maps.gstatic.com/mapfiles/place_api/icons/wine-71.png'
    ]
    network: ['*', 'http://*', 'https://*']

server:
  path: 'jst-server.coffee'

watcher:
  usePolling: true
</code></pre>

            <aside class="notes" data-markdown>

            </aside>
          </section>

          <section id="stack">
            <h1>La stack</h1>

            <p class="fragment"><a href="http://learnboost.github.io/stylus/">Stylus</a> et <a href="http://lesscss.org/">LESS</a> (<a href="http://getbootstrap.com/">Bootstrap</a>) pour les CSS</p>
            <p class="fragment"><a href="http://jade-lang.com/">Jade</a> pour le templating</p>
            <p class="fragment"><a href="http://backbonejs.org/">Backbone</a> pour le MVC côté client</p>
            <p class="fragment">W3C / HTML5 pour la <a href="https://developer.mozilla.org/fr/docs/Using_geolocation">géolocalisation</a> et la <a href="https://developer.mozilla.org/fr/docs/%C3%89v%C3%A8nements_online_et_offline">détection offline</a></p>
            <p class="fragment"><a href="https://developer.mozilla.org/fr/docs/DOM/Storage">sessionStorage</a> pour du stockage local transient</p>
            <p class="fragment"><a href="http://brian.io/lawnchair/">Lawnchair</a> pour l'abstraction de stockage local persistant</p>
            <p class="fragment"><a href="https://developers.google.com/maps/">Google Maps</a> pour l'obtention de POI où manger</p>
            <p class="fragment"><a href="https://developer.mozilla.org/fr/docs/Utiliser_Application_Cache">ApplicationCache</a> pour le cache offline</p>
            <p class="fragment"><a href="http://momentjs.com/">Moment.js</a> pour l'horloge et <a href="http://underscorejs.org/">Underscore.js</a> pour l'algo</p>
            <p class="fragment"><a href="http://nodejs.org/">Node</a> et <a href="http://coffeescript.org/">CoffeeScript</a> pour le serveur de démo</p>

            <aside class="notes" data-markdown>
              * Stylus : montrer le style sur l'élément body (sourcemap), less : montrer ce qui vient de bootstratp
              * Jade : montrer #checkInUI qui se trouve dans home.jade
              * * définition du block main
              * * inclusion de _layout.jade
              * * montrer au passage les FIXME dans #onlineMarker et #ticker
              * Backbone : dans initialize.js , juste montrer le require
              * geoloc : montrer sur spa-final
              * offline : plus tard
              * sessionStorage : sur spa-final, panneau ressources
              * lawnchair : site + montrer que externals/lawnchair-dom.js existe
              * Gmaps / offline : plus tard
              * Moment.js : montrer site
              * node et coffee : Montrer jst-server.coffee
              * * npm start => package.json => brunch watch => brunch-config => node jst-server.coffee
              * * get / : public/index.html => montre le body vide
            </aside>

          </section>

          <section id="spa-boot">
            <h1>« Boot »</h1>

            <p>Bon, pour le moment, je passe sous Keynote…</p>
            <aside class="notes" data-markdown>
              * montrer slides-material/spa-boot.pdf
              * initialize.js - require('moment') => expliquer que le chemin a été retravaillé par brunch-config - nameCleaner
              * à retenir
              * * on renseignera systématiquement template, afterRender et getRenderData
            </aside>
          </section>

          <section id="spa-steps">
            <h1>Pour aujourd'hui…</h1>

            <ol>
              <li>Faire tourner</li>
              <li>Récupérer et retenir le nom</li>
              <li>L’horloge</li>
              <li>Vues imbriquées</li>
              <li>Géolocalisation et Google Maps Places</li>
              <li>Modèle Backbone d’état UX</li>
            </ol>
          </section>

          <section id="spa-runit">
            <h1>Faire tourner</h1>
            <h3>le socle</h3>

            <pre><code data-trim data-noescape class="bash">
$ cd spa-basis
$ <u>npm install</u>
…
$ <u>npm start</u>

> js-total-spa@2.0.0 start …/spa-basis
> <u>brunch watch --server</u>

22 Oct 16:59:34 - info: starting custom server
Cannot load db.json
<b class="right">Listening on port 3333… WebSockets enabled.</b>
22 Oct 16:59:34 - info: custom server started, initializing watcher
22 Oct 16:59:35 - info: compiled 37 files and 1 cached into 2 files, copied…
            </code></pre>
            <aside class="notes" data-markdown>
              problèmes ?

              * tester avec brunch w
              * fenêtre > 950px pour voir la 2nde colonne
            </aside>
          </section>

          <section id="spa-username">
            <h1>Retenir le nom</h1>

            <p>Bon vieux <code>prompt</code> + persistance dans <code><a href="https://developer.mozilla.org/en-US/docs/Web/Guide/API/DOM/Storage#sessionStorage">sessionStorage</a></code></p>
            <p>Saisies pourries (<code>null</code>, whitespaces…), non persistées : nom l’aléatoire.  Première rencontre avec <a href="http://underscorejs.org">Underscore</a> :-)</p>
            <pre><code data-trim data-noescape class="javascript" data-file="lib/notifications.js">
var userName = <u>sessionStorage.</u>userName ||
  $.trim(<u>prompt</u>("Votre nom d’utilisateur"));
            </code></pre>

            <p>1er <code>getRenderData()</code> et variable dans un template Jade.</p>

            <pre><code data-trim data-noescape class="javascript" data-file="views/home_view.js">
getRenderData: function getHomeRenderData() {
  return { userName: userName };
}
            </code></pre>

            <pre><code data-trim data-noescape class="javascript" data-file="views/templates/_layout.jade">
              span<u>= userName</u>
            </code></pre>

            <aside class="notes" data-markdown>
              * démo de sessionStorage : sessionStorage
              * création app/lib/notificationS.js
              * var userName, prompt, exports => reload : toujours rien
              * édition home_view : require(notifications).userName, création getRenderData, return userName => prompt apparaît
              * édition _layout.jade : premier FIXME par span= userName. Faire un touch sur home.jade pour aider brunch à reload
              * retour notifications.js :
              * * save dans sessionStorage
              * * random si userName null => require underscore
              * * $ trim sur le prompt => require jquery
              * fermer notifications.js

            </aside>

          </section>

          <section id="backbone-views">
            <h1>Backbone.View</h1>
            <h3>Rien que l’essentiel (mais bien choisi)</h3>

            <p><code><a href="http://backbonejs.org/#View">Backbone.View</a></code> ne fournit/impose que peu de chose, mais top</p>
            <p>Conteneur DOM : <code>el</code>, <code>$el</code></p>
            <p>Gen du conteneur : <code>tagName</code>, <code>id</code>, <code>className</code>, <code>attributes</code></p>
            <p>Modèle associé : <code>model</code> / <code>collection</code></p>
            <p>Lookup jQuery <span lang="en">prescoped</span> : <code>$</code> (on fait <code>this.$(…)</code>)</p>
            <p>Rendering : <code>render()</code></p>
            <p>Délégation d’événements : <code>events</code></p>

            <aside class="notes" data-markdown>
              * View Backbone ressemble plus à un controler : ne suppose rien, plutôt bcp de conventions
              * on peut rendre global application.homeView pour l'inspecter (ex, dans router.js)
              * application.homeView.$el.jquery => la version jQuery
              * présenter views/view.js

            </aside>
          </section>

          <section id="spa-clock">
            <h1>L’horloge</h1>

            <p>Injection initiale + mise à jour ultérieure.</p>
            <p>Le DOM doit être garanti à jour : <code>afterRender</code>.</p>
            <p>Bon vieux <code>setInterval(…, 1000)</code></p>
            <pre><code data-trim data-noescape class="javascript" data-file="views/home_view.js">
<u>afterRender</u>: function afterHomeRender() {
  this.startClock();
},

// …

startClock: function startClock() {
  this._clock = this._clock || <u>this.$</u>('#ticker');
  <u>var that = this;</u>
  setInterval(function() {
    <u>that</u>._clock.text(<u>that</u>.getRenderData().now);
  }, 1000);
}
            </code></pre>

            <aside class="notes" data-markdown>
              * édition views/home_view.js : getRenderData, renvoi now : Date.now
              * injection initiale de l'heure : layout.jade : span#ticker= now (toucher home.jade pour prise en compte par brunch)
              * timestamp apparaît ? présentation moment.js + require + format('dddd D MMMM YYYY HH:mm:ss')

              * Mise à jour : exécuter en console application.homeView.render()
              * création de afterRender() => this.startClock()
              * création de startClock() => MAJ + setInterval
              * ça marche, fermeture de home.jade et layout.jade
            </aside>
          </section>

          <section id="spa-nested-views">
            <h1>Vues imbriquées</h1>

            <p>Le pavé de gauche contient une vue complexe avec des tas de gestions spécifiques : on va en faire un contrôleur (<code>Backbone.View</code>) dédié, et l'intégrer dans la vue racine.</p>
            <pre><code data-trim data-noescape class="javascript" data-file="views/check_in_view.js">
var View = require('./view');

module.exports = View.extend({
  template: require('./templates/<u>check_in</u>')
});
            </code></pre>

            <pre><code data-trim data-noescape class="javascript" data-file="views/home_view.js">
var CheckInView = require('./check_in_view');

// …

  afterRender: function afterHomeRender() {
    this.startClock();
    <u>new CheckInView({ el: this.$('#checkInUI') }).render();</u>
  },
            </code></pre>

            <aside class="notes" data-markdown>
              * création views/check_in_view.js . Conseiller de copier / coller depuis home_view
              * on garde juste require(view), template: templates/check_in
              * modif home_view ( require + new  CheckInView().render
              * plomberie OK (affichage col gauche), on peut fermer home_view.js
            </aside>

          </section>

          <section id="spa-geoloc">
            <h1>Géolocalisation</h1>

            <p>On a 2 modules qui nous découplent des technos sous-jacente :</p>
            <p><code>lib/location</code> par-dessus la <a href="https://developer.mozilla.org/fr/docs/Using_geolocation">géoloc W3C</a></p>
            <p><code>lib/places</code> par-dessus <a href="https://developers.google.com/places/documentation/?hl=fr">Google Places</a></p>

            <pre><code data-trim data-noescape class="javascript" data-file="views/check_in_view.js">
afterRender: function() {
  this.fetchPlaces();
},

fetchPlaces: function() {
  <u>locSvc.getCurrentLocation</u>(function(lat, lng) {
    console.log(lat, lng);
    if (_.isString(lat)) {
      return;
    }
    <u>poiSvc.lookupPlaces</u>(lat, lng, function(places) {
      console.log(places);
    });
  });
}
            </code></pre>

            <aside class="notes" data-markdown>
              * retour à check_in_view.js
              * création afterRender
              * création fetchPlaces avec console
              * console s'affiche ?

              Explication des services

              * explication HMTL5 geoloc, + démo : navigator.geolocation.getCurrentPosition(function() { console.log( arguments ); }); (permission à accorder à Chrome)
              * parler de lib/location
              * * export de getCurrentLocation
              * * $FAKE, offline, vieux navigateur : coordonnées en dur, pratique pour dev
              * * cache en localStorage
              * **require lib/location**, appel de getCurrentLocation, console
              * parler de lib/places
              * * gestion offline, filtres des restaus, stockage local, $FAKE
              * * complexité de l'API V3 (pas un vrai Web Service), API super lourde
              * * gestion des timeout, et re-essai automatique
              * * gestion du double appel (recherche + distance),puis tri
              * * au final lookupPlaces(lat, lng, callback)
              * **require lib/places**
              * dans callback de getCurrentLocation : lookupPlaces() => console.log(places)


              Affichage :

              * montrer check_in.jade, mettre != placeList (pour le HTML non escaped)
              * éditer check_in_view, getRenderData, return placeList:'searching…'
              * ajout de listTemplate:require places, puis exécution du template dans getRenderData, via View.renderTemplate
              * pourquoi le spinner tourne toujours ? > MAJ du DOM à faire. On pourrait faire comme pour l'heure (jQuery direct => pas descriptif OU that.render() => boucle infinie ), mais on va plutôt faire du data-binding
            </aside>
          </section>

          <section id="spa-ux-model">
            <h1>Modèle Backbone</h1>
            <h3>pour l’état de l’UX</h3>

            <p>Passer par du data-binding pour contrôler proprement l’état de l’UI et l’UX en fonction des éléments de l’état de la vue (latitude, longitude, POIs, sélection, commentaire…).</p>

            <p>Le plugin le plus abouti est actuellement <a href="http://nytimes.github.io/backbone.stickit/">Backbone.StickIt</a></p>
            <pre><code data-trim data-noescape class="javascript" data-file="views/check_in_view.js">
<u>bindings</u>: {
  // sélecteur CSS -> descripteur de binding, +/- avancé
  '#comment': 'comment',
  '#places': {
    observe: ['places', 'placeId'],
    onGet: function() { return this.getRenderData().placeList; },
    updateMethod: 'html'
  },
  // …
}
            </code></pre>
            <aside class="notes" data-markdown>
              Explication modèle Backbone

              * regroupable en Collection avec toutes les méthodes de underscore (add, pick, pop, push, sort, findWhere, comparator …)
              * hérite de méthodes undersore : pick, omit
              * synchronisation automatique possible avec le serveur (plus tard) (sync, fetch, save)
              * events (change, )
              * get / set / toJSON


              * explication de ce que l'on veut représenter : stocker lat/lng, resto sélectionné, dernière liste des restos, commentaire
              * Création models/check_in_ux.js
              * * recopie de models/check_in.js
              * * ajout des defaults pour lat, lng, placeId, places, comment
              * modif check_in_view
              * * création méthode initialize, avec appel du parent et définition du modèle + console.log(this.model.toJSON());
              * * dans getCurrentLocation : model.set lat lng
              * * dans lookupPlaces : model.set places
              * * dans getRenderData : this.model.get('places')
              * * tester avec un that.render() pour montrer la MAJ (boucle infinie)

              Explication data-binding (moins de manip DOM, pas de markup dans le HTML), des librairies dédiées (knockoutJS, Angular…), puis stickit

              * montrer que stickit vient de app/initialize.js : require('backbone-stickit')
              * démo avec commentaire mis en dur dans les défauts "bindings"
              * version plus compliquée (2 variables à observer, formatage) avec #geoloc. Montrer la doc : http://nytimes.github.io/backbone.stickit/#bindings/observe
              * places, avec getRenderData().placeList + updateMethod à html (text par défaut)
              * expliquer le template places.jade au passage (each, unless, if ternaire, helper secondsToMinutes défini dans lib/view_helper)
              * affichage lat / lng et liste des restaus OK

            </aside>
          </section>


          <section id="spa-backbone-events">
            <h1>Events Backbone</h1>

            <p>Système de convention pour écouter les actions sur l'UX et y lier des méthodes de la View.</p>

            <p>Très efficace : gère la délégation d'événements, le verrouillage du contexte d'exécution (<code>this</code>) et se limite aux enfants de <code>this.$el</code></p>
            <pre><code data-trim data-noescape class="javascript" data-file="views/check_in_view.js">
<u>events</u>: {
  // La clé est composée du nom de l'événement et du sélecteur CSS.
  // La valeur est le nom de la méthode du controler
  'click header button': 'fetchPlaces',
  'click #places li': 'selectPlace',
  'submit': 'checkIn'
}
            </code></pre>
            <aside class="notes" data-markdown>
              * explication events View Backbone. Équivalent à $(this.el).on('click', 'header button', \\_.bind( this.fetchPlaces, this) ))

              Bouton rechercher qui relance la recherche

              * ajout events, avec seulement 'click header button':'fetchPlaces'
              * dans fetchPlaces : model set defaults


              sélection du POI

              * but : mettre une classe active, extraire le placeId
              * events : click #places li': 'selectPlace',
              * création selectPlace. Démo du this, e.target et e.currentTarget
              * mise à jour du model : placeId
              * montrer places.jade : le if sur la classe active. Demander comment on remet à jour ?
              * dans bindings, #places, observe : rajout de placeId
              * dans getRenderData, rajout de placeId. utiliser model.pick(places, placeId)
              * sélection OK, un clic sur le bouton doit aussi marcher (re-fetch et reset)


              détails du submit : ON à la sélection, OFF au submit et pendant la recherche

              * bindings de button[type=submit], utilisation de attributes http://nytimes.github.io/backbone.stickit/#attribute-and-property-bindings/attributes
              * on tente avec observer : placeId. Pas bon car null = falsy, il nous faut justement le contraire. Équivalent conceptuel des computed de Knockout
              * création dans check\\_in\\_ux de initialize : checkCheckinable, exécution immédiate, écoute du on change du model
              * update du observe pour écouter checkInForbidden
              * vérifier dans l'interface : OFF par défaut, sélection = ON, recherche = OFF. Click sur bouton = validation du formulaire


              submit : récupération des infos du resto

              * ajout dans events submit checkIn, création checkIn
              * fonction checkIn : preventDefault
              * vérification de checkInForbidden => return
              * récupération des infos : faire trouver _.findWhere(this.model.get('places'), { id: this.model.get('placeId') });
              * console.log des infos de checkIn. Rajouter userName (require lib/notifications) et comment (dans le model grâce au binding bi-directionnel sur les éléments de formulaire http://nytimes.github.io/backbone.stickit/#form-element-bindings-and-contenteditable)
              * désélection et suppression du commentaire via modèle (placeId:null et comment:'')

            </aside>
          </section>
        </section>

        <section id="next-day">
          <h1>À suivre…</h1>

          <h3>Coder la suite de la SPA</h3>

          <ul>
            <li>Persistence serveur</li>
            <li>Online/offline</li>
            <li>Stockage local</li>
            <li>Web sockets</li>
            <li>Routes multiples</li>
            <li>AppCache</li>
          </ul>

          <h3>À <span data-marker="next-day-name">demain</span>&nbsp;!</h3>
        </section>
      </div>
    </div>

    <script src="lib/js/head.min.js"></script>
    <script src="js/reveal.js"></script>

    <script>
      // Full list of configuration options available here:
      // https://github.com/hakimel/reveal.js#configuration
      Reveal.initialize({
        controls: true,
        progress: true,
        history: true,
        center: true,

        theme: Reveal.getQueryHash().theme, // available themes are in /css/theme
        transition: Reveal.getQueryHash().transition || 'default', // default/cube/page/concave/zoom/linear/fade/none

        // Parallax scrolling
        // parallaxBackgroundImage: 'https://s3.amazonaws.com/hakim-static/reveal-js/reveal-parallax-1.jpg',
        // parallaxBackgroundSize: '2100px 900px',

        // Optional libraries used to extend on reveal.js
        dependencies: [
          { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
          { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
          { src: 'plugin/highlight/highlight.js', async: true, callback: function() { hljs.initHighlightingOnLoad(); } },
          { src: 'plugin/notes/notes.js', async: true, condition: function() { return !!document.body.classList; } }
        ]
      });
    </script>
  </body>
</html>
